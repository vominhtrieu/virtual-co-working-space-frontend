/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useState } from "react";
import { useGLTF, useAnimations } from "@react-three/drei";
import { useFrame, useThree } from "@react-three/fiber";
import * as THREE from "three";

const MovingSpeed = 5;
export default function Character(props) {
    const group = useRef();
    const rotateAngle = useRef(new THREE.Vector3(0, 1, 0));
    const rotateQuarternion = useRef(new THREE.Quaternion());
    const walkDirection = useRef(new THREE.Vector3());
    const currentClip = useRef(null);
    const { nodes, materials, animations } = useGLTF("/models/Character.glb");
    const { orbitRef } = props;

    const { actions, mixer } = useAnimations(animations, group);
    const [keyPressed, setKeyPressed] = useState({});

    const getMovingVector = () => {
        const vector = new THREE.Vector3();
        if (!keyPressed) {
            return vector;
        }
        if (keyPressed.ArrowUp || keyPressed.W) {
            vector.z = 1;
        }
        if (keyPressed.ArrowDown || keyPressed.S) {
            if (keyPressed.ArrowUp || keyPressed.W) {
                vector.z = 0;
            } else {
                vector.z = -1;
            }
        }

        if (keyPressed.ArrowRight || keyPressed.D) {
            vector.x = 1;
        }
        if (keyPressed.ArrowLeft || keyPressed.A) {
            if (keyPressed.ArrowRight || keyPressed.D) {
                vector.x = 0;
            } else {
                vector.x = -1;
            }
        }
        return vector;
    };

    const isMoving = () => {
        const moveVector = getMovingVector();
        return Math.abs(moveVector.x) > 0.1 || Math.abs(moveVector.z) > 0.1;
    };
    const getDirectionOffset = () => {
        const vector = getMovingVector();
        var directionOffset = 0;
        if (vector.z === 1) {
            if (vector.x === -1) {
                directionOffset = Math.PI + Math.PI / 4;
            } else if (vector.x === 1) {
                directionOffset = Math.PI - Math.PI / 4;
            } else {
                directionOffset = Math.PI;
            }
        } else if (vector.z === -1) {
            if (vector.x === -1) {
                directionOffset = 2 * Math.PI - Math.PI / 4;
            } else if (vector.x === 1) {
                directionOffset = 2 * Math.PI + Math.PI / 4;
            } else {
                directionOffset = 2 * Math.PI;
            }
        } else {
            directionOffset = -(-vector.x * Math.PI) / 2;
        }
        return directionOffset;
    };

    useThree(({ camera }) => {
        if (!props.moveable) {
            camera.position.set(0, 0, 5);
            camera.rotation.set(0, 0, 0);
        }
    });

    useFrame((state, delta) => {
        if (!props.moveable) {
            return;
        }
        const { camera } = state;
        let clip = null;
        if (props.moveable && isMoving()) {
            clip = actions.Walking;

            const yCameraDirection = Math.atan2(
                camera.position.x - group.current.position.x,
                camera.position.z - group.current.position.z
            );
            const directionOffset = getDirectionOffset();
            rotateQuarternion.current.setFromAxisAngle(rotateAngle.current, yCameraDirection + directionOffset);
            group.current.quaternion.rotateTowards(rotateQuarternion.current, delta * 10);
            camera.getWorldDirection(walkDirection.current);
            walkDirection.current.y = 0;
            walkDirection.current.normalize();
            walkDirection.current.applyAxisAngle(rotateAngle.current, directionOffset + Math.PI);
            const moveX = walkDirection.current.x * MovingSpeed * delta;
            const moveZ = walkDirection.current.z * MovingSpeed * delta;
            group.current.position.x += moveX;
            group.current.position.z += moveZ;

            camera.position.x += moveX;
            camera.position.z += moveZ;
            if (orbitRef.current) {
                orbitRef.current.target = group.current.position;
            }
        } else {
            clip = actions.Idle;
        }
        if (clip && clip !== currentClip.current) {
            if (currentClip.current) {
                currentClip.current.fadeOut(0.2);
            }
            clip.reset().fadeIn(0.2).play();
            currentClip.current = clip;
        }
        currentClip.current = clip;
        mixer.update(delta * 0.2);
    });

    React.useEffect(() => {
        actions.Idle.play();
        if (!props.moveable) {
            return;
        }
        document.addEventListener("keydown", (event) => {
            setKeyPressed((keyPressed) => ({ ...keyPressed, [event.key]: true }));
        });
        document.addEventListener("keyup", (event) => {
            setKeyPressed((keyPressed) => ({ ...keyPressed, [event.key]: false }));
        });
        orbitRef.current.target = group.current.position;
    }, [actions.Idle, orbitRef, group, props.moveable]);

    React.useEffect(() => {
        if (group.current) {
            group.current.position.set(props.startPosition[0], props.startPosition[1], props.startPosition[2]);
        }
    }, [props.startPosition]);

    return (
        <group ref={group} {...props} dispose={null} castShadow={true}>
            <primitive object={nodes.mixamorigHips} />
            <primitive object={nodes.Ctrl_ArmPole_IK_Left} />
            <primitive object={nodes.Ctrl_Hand_IK_Left} />
            <primitive object={nodes.Ctrl_ArmPole_IK_Right} />
            <primitive object={nodes.Ctrl_Hand_IK_Right} />
            <primitive object={nodes.Ctrl_Foot_IK_Left} />
            <primitive object={nodes.Ctrl_LegPole_IK_Left} />
            <primitive object={nodes.Ctrl_Foot_IK_Right} />
            <primitive object={nodes.Ctrl_LegPole_IK_Right} />
            <primitive object={nodes.Ctrl_Master} />
            <skinnedMesh
                geometry={nodes.Cube001.geometry}
                material={materials.Body}
                skeleton={nodes.Cube001.skeleton}
            />
            <skinnedMesh
                geometry={nodes.Cube001_1.geometry}
                material={materials.Head}
                skeleton={nodes.Cube001_1.skeleton}
            />
            <skinnedMesh
                geometry={nodes.Cube001_2.geometry}
                material={props.eyes === 1 ? materials["Eye 1"] : materials["Eye 2"]}
                skeleton={nodes.Cube001_2.skeleton}
            />
            {props.hair === 1 ? (
                <skinnedMesh
                    geometry={nodes.Hair_1.geometry}
                    material={materials["Hair 1"]}
                    skeleton={nodes.Hair_1.skeleton}
                />
            ) : (
                <skinnedMesh
                    geometry={nodes.Hair_2.geometry}
                    material={materials["Hair 2"]}
                    skeleton={nodes.Hair_2.skeleton}
                />
            )}
            <skinnedMesh geometry={nodes.Shoe.geometry} material={materials.Shoes} skeleton={nodes.Shoe.skeleton} />
        </group>
    );
}

useGLTF.preload("/Character.glb");
