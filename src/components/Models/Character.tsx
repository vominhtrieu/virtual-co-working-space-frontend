/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from 'three'
import {useEffect, useRef, useState} from 'react'
import {useGLTF, useAnimations} from '@react-three/drei'
import {useThree, useFrame} from '@react-three/fiber'
import {useCylinder} from '@react-three/cannon'
import {GLTFActions, GLTFResult, useCustomGLTF} from "../../helpers/utilities";
import socket from "../../services/socket/socket"

type CharacterProps = JSX.IntrinsicElements['group'] & {
    hair: number,
    eyes: number,
    movable: boolean,
    startPosition: number[],
    orbitRef?: any
}

type KeyProps = {
    ArrowUp?: boolean,
    ArrowDown?: boolean,
    ArrowLeft?: boolean,
    ArrowRight?: boolean,
    W?: boolean,
    S?: boolean,
    A?: boolean,
    D?: boolean
    w?: boolean,
    s?: boolean,
    a?: boolean,
    d?: boolean
}

const MovingSpeed: number = 6;
export default function Character(props: CharacterProps) {
    const group = useRef<THREE.Group>()
    const [ref, api] = useCylinder(() => ({
        args: [1, 1, 4, 8],
        type: "Dynamic",
        fixedRotation: true,
        mass: 1,
    }))
    const rotateAngle = useRef<THREE.Vector3>(new THREE.Vector3(0, 1, 0));
    const rotateQuaternion = useRef(new THREE.Quaternion());
    const walkDirection = useRef(new THREE.Vector3());
    const currentClip = useRef<THREE.AnimationClip>(null);
    const {nodes, materials, animations} = useCustomGLTF('/models/Character.glb') as GLTFResult
    const {actions, mixer} = useAnimations<GLTFActions>(animations, group);

    const {orbitRef} = props;
    const [keyPressed, setKeyPressed] = useState<KeyProps>({});

    const position = useRef([0, 0, 0])
    const updatedPosition = useRef(props.startPosition)
    const rotation = useRef([0, 0, 0]);

    const count = useRef(0);

    useEffect(() => {
        socket.emit("office_member:join", {
            officeId: "1"
        })
    }, [])

    useEffect(() => {
        api.position.subscribe((v) => {
            position.current = v;
        })
        api.rotation.subscribe((v) => {
            rotation.current = v;
        })
    }, [api.position])

    const getMovingVector = () => {
        const vector = new THREE.Vector3();
        if (!keyPressed) {
            return vector;
        }
        if (keyPressed.ArrowUp || keyPressed.W || keyPressed.w) {
            vector.z = 1;
        }
        if (keyPressed.ArrowDown || keyPressed.S || keyPressed.s) {
            if (keyPressed.ArrowUp || keyPressed.W || keyPressed.w) {
                vector.z = 0;
            } else {
                vector.z = -1;
            }
        }

        if (keyPressed.ArrowRight || keyPressed.D || keyPressed.d) {
            vector.x = 1;
        }
        if (keyPressed.ArrowLeft || keyPressed.A || keyPressed.a) {
            if (keyPressed.ArrowRight || keyPressed.D || keyPressed.d) {
                vector.x = 0;
            } else {
                vector.x = -1;
            }
        }
        return vector;
    };

    const isMoving = () => {
        const moveVector = getMovingVector();
        return Math.abs(moveVector.x) > 0.1 || Math.abs(moveVector.z) > 0.1;
    };

    const getDirectionOffset = () => {
        const vector = getMovingVector();
        var directionOffset = 0;
        if (vector.z === 1) {
            if (vector.x === -1) {
                directionOffset = Math.PI + Math.PI / 4;
            } else if (vector.x === 1) {
                directionOffset = Math.PI - Math.PI / 4;
            } else {
                directionOffset = Math.PI;
            }
        } else if (vector.z === -1) {
            if (vector.x === -1) {
                directionOffset = 2 * Math.PI - Math.PI / 4;
            } else if (vector.x === 1) {
                directionOffset = 2 * Math.PI + Math.PI / 4;
            } else {
                directionOffset = 2 * Math.PI;
            }
        } else {
            directionOffset = -(-vector.x * Math.PI) / 2;
        }
        return directionOffset;
    };

    const shouldUpdate = () => {
        return Math.sqrt(Math.pow(position.current[0] - updatedPosition.current[0], 2) + Math.pow(position.current[2] - updatedPosition.current[2], 2)) > 0.1
    }

    useThree(({camera}) => {
        if (!props.moveable) {
            camera.position.set(0, 0, 5);
            camera.rotation.set(0, 0, 0);
        }
    });

    useFrame((state, delta) => {
        const {camera} = state;
        let clip: THREE.AnimationClip = null;
        //console.log(rotation);
        

        if (props.movable && isMoving()) {
            count.current++;
            clip = actions.Walking;

            const yCameraDirection = Math.atan2(
                camera.position.x - ref.current.position.x,
                camera.position.z - ref.current.position.z
            );
            const directionOffset = getDirectionOffset();
            rotateQuaternion.current.setFromAxisAngle(rotateAngle.current, yCameraDirection + directionOffset);
            ref.current.quaternion.rotateTowards(rotateQuaternion.current, delta * 10);
            camera.getWorldDirection(walkDirection.current);
            walkDirection.current.y = 0;
            walkDirection.current.normalize();
            walkDirection.current.applyAxisAngle(rotateAngle.current, directionOffset + Math.PI);
            // console.log(directionOffset);
            const moveX = walkDirection.current.x * MovingSpeed ;
            const moveZ = walkDirection.current.z * MovingSpeed ;

            api.velocity.set(moveX, 0, moveZ);

            // camera.position.copy(api.position);
            api.quaternion.copy(ref.current.quaternion)

            if (orbitRef.current) {
                orbitRef.current.target = ref.current.position;
            }

            updatedPosition.current = position.current;
            
            if (count.current >= 2) {
                socket.emit("office_member:move", {
                    xRotation: rotation.current[0],
                    yRotation: rotation.current[1],
                    zRotation: rotation.current[2],
                    xPosition: position.current[0],
                    yPosition: position.current[1],
                    zPosition: position.current[2]
                })
                count.current = 0;
            }

        } else {
            clip = actions.Idle;
            api.velocity.set(0, 0, 0);
        }
        
        //update from remote position
        if (shouldUpdate()) {
            clip = actions.Walking;
            const tempVector = new THREE.Vector3();
            const quaternion = new THREE.Quaternion()

            const newDirection = new THREE.Vector3(updatedPosition.current[0] - position.current[0], 0, updatedPosition.current[2] - position.current[2]);
            // newDirection.normalize();
            // walkDirection.current.normalize();

        //     const dot = walkDirection.current.dot(newDirection);
        //     if (dot < -0.999999) {
        //         tempVector.crossVectors(new THREE.Vector3(1, 0, 0), walkDirection.current);
        //         if (tempVector.length() < 0.000001) {
        //             tempVector.crossVectors(new THREE.Vector3(0, 1, 0), walkDirection.current);
        //         }
        //         tempVector.normalize();
        //         quaternion.setFromAxisAngle(tempVector, Math.PI);
        //    } else if (dot > 0.999999) {
        //        quaternion.x = quaternion.y = quaternion.z = 0;
        //        quaternion.w = 1;
        //    } else {
        //        tempVector.crossVectors(walkDirection.current, newDirection);
        //        quaternion.x = tempVector.x;
        //        quaternion.y = tempVector.y;
        //        quaternion.z = tempVector.z;
        //        quaternion.w = 1 + dot;
        //        quaternion.normalize();
        //    }
            const angle = newDirection.angleTo(walkDirection.current);

            //quaternion.setFromAxisAngle(rotateAngle.current, newDirection.angleTo(walkDirection.current))
            //ref.current.quaternion.rotateTowards(quaternion, delta * 10);

            walkDirection.current = new THREE.Vector3(updatedPosition.current[0] - position.current[0], 0, updatedPosition.current[2] - position.current[2]);
            walkDirection.current.y = 0;
            walkDirection.current.normalize();
            const moveX = walkDirection.current.x * MovingSpeed;
            const moveZ = walkDirection.current.z * MovingSpeed;

            api.velocity.set(moveX, 0, moveZ);
            //api.quaternion.copy(ref.current.quaternion);
        }

        if (clip && clip !== currentClip.current) {
            if (currentClip.current) {
                currentClip.current.fadeOut(0.2);
            }
            clip.reset().fadeIn(0.2).play();
            currentClip.current = clip;
        }
        currentClip.current = clip;
        mixer.update(delta * 0.2);
    });

    useEffect(() => {
        actions.Idle?.play();
        if (!props.movable) {
            return;
        }

        document.addEventListener("keydown", (event) => {
            setKeyPressed((keyPressed) => ({...keyPressed, [event.key]: true}));
        });
        document.addEventListener("keyup", (event) => {
            setKeyPressed((keyPressed) => ({...keyPressed, [event.key]: false}));
        });

        orbitRef.current.target = ref.current?.position;
    }, [orbitRef, ref, props.movable]);

    useEffect(() => {
        if (ref.current) {
            ref.current.position.set(props.startPosition[0], props.startPosition[1], props.startPosition[2]);
            api.position.set(props.startPosition[0], props.startPosition[1], props.startPosition[2]);
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [ref.current, props.startPosition]);

    socket.on("office_member:moved", (message) => {
        updatedPosition.current = [message.xPosition, message.yPosition, message.zPosition];
        api.rotation.set(message.xRotation, message.yRotation, message.zRotation)   
    })

    socket.on("office_member:error", (message) => {
        console.log(message);
    })
    
    socket.on("connect_error", message => {
        console.log("connection error: ", message);
        
    })

    return (
        <>
            <mesh ref={ref} {...props}>
                <group ref={group} position={[0, -1, 0]} dispose={null}>
                    <primitive object={nodes.mixamorigHips}/>
                    <primitive object={nodes.Ctrl_ArmPole_IK_Left}/>
                    <primitive object={nodes.Ctrl_Hand_IK_Left}/>
                    <primitive object={nodes.Ctrl_ArmPole_IK_Right}/>
                    <primitive object={nodes.Ctrl_Hand_IK_Right}/>
                    <primitive object={nodes.Ctrl_Foot_IK_Left}/>
                    <primitive object={nodes.Ctrl_LegPole_IK_Left}/>
                    <primitive object={nodes.Ctrl_Foot_IK_Right}/>
                    <primitive object={nodes.Ctrl_LegPole_IK_Right}/>
                    <primitive object={nodes.Ctrl_Master}/>
                    <skinnedMesh geometry={nodes.Cube001.geometry} material={materials.Body}
                                 skeleton={nodes.Cube001.skeleton}/>
                    <skinnedMesh geometry={nodes.Cube001_1.geometry} material={materials.Head}
                                 skeleton={nodes.Cube001_1.skeleton}/>
                    <skinnedMesh
                        geometry={nodes.Cube001_2.geometry}
                        material={props.eyes === 1 ? materials["Eye 1"] : materials["Eye 2"]}
                        skeleton={nodes.Cube001_2.skeleton}
                    />
                    {props.hair === 1 ? (
                        <skinnedMesh
                            geometry={nodes.Hair_1.geometry}
                            material={materials["Hair 1"]}
                            skeleton={nodes.Hair_1.skeleton}
                        />
                    ) : (
                        <skinnedMesh
                            geometry={nodes.Hair_2.geometry}
                            material={materials["Hair 2"]}
                            skeleton={nodes.Hair_2.skeleton}
                        />
                    )}
                    <skinnedMesh geometry={nodes.Shoe.geometry} material={materials.Shoes}
                                 skeleton={nodes.Shoe.skeleton}/>
                </group>
            </mesh>
        </>
    )
}

useGLTF.preload('/Character.glb')
