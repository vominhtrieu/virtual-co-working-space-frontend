/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from 'three'
import {useEffect, useRef, useState} from 'react'
import {useGLTF, useAnimations} from '@react-three/drei'
import {useThree, useFrame} from '@react-three/fiber'
import {Triplet, useCylinder} from '@react-three/cannon'
import {GLTFActions, GLTFResult, useCustomGLTF} from "../../helpers/utilities";

type CharacterProps = JSX.IntrinsicElements['group'] & {
    hair: number,
    eyes: number,
    movable: boolean,
    startPosition: number[],
    orbitRef?: any
}

type KeyProps = {
    ArrowUp?: boolean,
    ArrowDown?: boolean,
    ArrowLeft?: boolean,
    ArrowRight?: boolean,
    W?: boolean,
    S?: boolean,
    A?: boolean,
    D?: boolean
    w?: boolean,
    s?: boolean,
    a?: boolean,
    d?: boolean
}

const MovingSpeed: number = 6;
export default function Character(props: CharacterProps) {
    const group = useRef<THREE.Group>()
    const [ref, api] = useCylinder(() => ({
        args: [1, 1, 4, 8],
        type: "Dynamic",
        fixedRotation: true,
        mass: 1,
    }))
    const rotateAngle = useRef<THREE.Vector3>(new THREE.Vector3(0, 1, 0));
    const rotateQuaternion = useRef(new THREE.Quaternion());
    const walkDirection = useRef(new THREE.Vector3());
    const currentClip = useRef<THREE.AnimationClip>(null);
    const {nodes, materials, animations} = useCustomGLTF('/models/Character.glb') as GLTFResult
    const {actions, mixer} = useAnimations<GLTFActions>(animations, group);

    const {orbitRef} = props;
    const [keyPressed, setKeyPressed] = useState<KeyProps>({});

    const getMovingVector = () => {
        const vector = new THREE.Vector3();
        if (!keyPressed) {
            return vector;
        }
        if (keyPressed.ArrowUp || keyPressed.W || keyPressed.w) {
            vector.z = 1;
        }
        if (keyPressed.ArrowDown || keyPressed.S || keyPressed.s) {
            if (keyPressed.ArrowUp || keyPressed.W || keyPressed.w) {
                vector.z = 0;
            } else {
                vector.z = -1;
            }
        }

        if (keyPressed.ArrowRight || keyPressed.D || keyPressed.d) {
            vector.x = 1;
        }
        if (keyPressed.ArrowLeft || keyPressed.A || keyPressed.a) {
            if (keyPressed.ArrowRight || keyPressed.D || keyPressed.d) {
                vector.x = 0;
            } else {
                vector.x = -1;
            }
        }
        return vector;
    };

    const isMoving = () => {
        const moveVector = getMovingVector();
        return Math.abs(moveVector.x) > 0.1 || Math.abs(moveVector.z) > 0.1;
    };

    const getDirectionOffset = () => {
        const vector = getMovingVector();
        var directionOffset = 0;
        if (vector.z === 1) {
            if (vector.x === -1) {
                directionOffset = Math.PI + Math.PI / 4;
            } else if (vector.x === 1) {
                directionOffset = Math.PI - Math.PI / 4;
            } else {
                directionOffset = Math.PI;
            }
        } else if (vector.z === -1) {
            if (vector.x === -1) {
                directionOffset = 2 * Math.PI - Math.PI / 4;
            } else if (vector.x === 1) {
                directionOffset = 2 * Math.PI + Math.PI / 4;
            } else {
                directionOffset = 2 * Math.PI;
            }
        } else {
            directionOffset = -(-vector.x * Math.PI) / 2;
        }
        return directionOffset;
    };

    const position = useRef<Triplet>();
    useEffect(() => {
        if (!props.movable) {
            return;
        }
        api.position.subscribe((_position: Triplet) => {
            position.current = _position;
        })
    })


    useFrame((state, delta) => {
        if (!props.movable) {
            return;
        }
        const {camera} = state;
        let clip: THREE.AnimationClip = null;

        if (props.movable && isMoving()) {
            clip = actions.Walking;

            const yCameraDirection = Math.atan2(
                camera.position.x - ref.current.position.x,
                camera.position.z - ref.current.position.z
            );
            const directionOffset = getDirectionOffset();
            rotateQuaternion.current.setFromAxisAngle(rotateAngle.current, yCameraDirection + directionOffset);
            ref.current.quaternion.rotateTowards(rotateQuaternion.current, delta * 10);
            camera.getWorldDirection(walkDirection.current);
            walkDirection.current.y = 0;
            walkDirection.current.normalize();
            walkDirection.current.applyAxisAngle(rotateAngle.current, directionOffset + Math.PI);

            const moveX = walkDirection.current.x * MovingSpeed;
            const moveZ = walkDirection.current.z * MovingSpeed;

            api.velocity.set(moveX, 0, moveZ);

            // camera.position.copy(api.position);
            api.quaternion.copy(ref.current.quaternion)
        } else {
            clip = actions.Idle;
            api.velocity.set(0, 0, 0);
        }
        if (orbitRef.current) {
            orbitRef.current.target = new THREE.Vector3(position[0], position[1], position[2]);
        }
        if (clip && clip !== currentClip.current) {
            if (currentClip.current) {
                currentClip.current.fadeOut(0.2);
            }
            clip.reset().fadeIn(0.2).play();
            currentClip.current = clip;
        }
        currentClip.current = clip;
        mixer.update(delta * 0.2);
    });

    useEffect(() => {
        actions.Idle?.play();
        if (!props.movable) {
            return;
        }

        document.addEventListener("keydown", (event) => {
            setKeyPressed((keyPressed) => ({...keyPressed, [event.key]: true}));
        });
        document.addEventListener("keyup", (event) => {
            setKeyPressed((keyPressed) => ({...keyPressed, [event.key]: false}));
        });

        orbitRef.current.target = ref.current?.position;
    }, [orbitRef, ref, props.movable]);

    useEffect(() => {
        if (ref.current) {
            ref.current.position.set(props.startPosition[0], props.startPosition[1], props.startPosition[2]);
            api.position.set(props.startPosition[0], props.startPosition[1], props.startPosition[2]);
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [ref.current, props.startPosition]);

    return (
        <>
            <mesh ref={ref} {...props}>
                <group ref={group} position={[0, -1, 0]} dispose={null}>
                    <primitive object={nodes.mixamorigHips}/>
                    <primitive object={nodes.Ctrl_ArmPole_IK_Left}/>
                    <primitive object={nodes.Ctrl_Hand_IK_Left}/>
                    <primitive object={nodes.Ctrl_ArmPole_IK_Right}/>
                    <primitive object={nodes.Ctrl_Hand_IK_Right}/>
                    <primitive object={nodes.Ctrl_Foot_IK_Left}/>
                    <primitive object={nodes.Ctrl_LegPole_IK_Left}/>
                    <primitive object={nodes.Ctrl_Foot_IK_Right}/>
                    <primitive object={nodes.Ctrl_LegPole_IK_Right}/>
                    <primitive object={nodes.Ctrl_Master}/>
                    <skinnedMesh geometry={nodes.Cube001.geometry} material={materials.Body}
                                 skeleton={nodes.Cube001.skeleton}/>
                    <skinnedMesh geometry={nodes.Cube001_1.geometry} material={materials.Head}
                                 skeleton={nodes.Cube001_1.skeleton}/>
                    <skinnedMesh
                        geometry={nodes.Cube001_2.geometry}
                        material={props.eyes === 1 ? materials["Eye 1"] : materials["Eye 2"]}
                        skeleton={nodes.Cube001_2.skeleton}
                    />
                    {props.hair === 1 ? (
                        <skinnedMesh
                            geometry={nodes.Hair_1.geometry}
                            material={materials["Hair 1"]}
                            skeleton={nodes.Hair_1.skeleton}
                        />
                    ) : (
                        <skinnedMesh
                            geometry={nodes.Hair_2.geometry}
                            material={materials["Hair 2"]}
                            skeleton={nodes.Hair_2.skeleton}
                        />
                    )}
                    <skinnedMesh geometry={nodes.Shoe.geometry} material={materials.Shoes}
                                 skeleton={nodes.Shoe.skeleton}/>
                </group>
            </mesh>
        </>
    )
}

useGLTF.preload('/Character.glb')
