/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from 'three'
import { useEffect, useRef, useState } from 'react'
import { useGLTF, useAnimations } from '@react-three/drei'
import { useThree, useFrame } from '@react-three/fiber'
import { GLTF } from 'three-stdlib/loaders/GLTFLoader'
import { Triplet, useCylinder } from '@react-three/cannon'

type ActionName = 'Idle' | 'Walking'
//type GLTFActions = Record<ActionName, THREE.AnimationAction>
interface GLTFActions extends THREE.AnimationClip {
  name: ActionName
}

type GLTFResult = GLTF & {
  nodes: {
    Cube001: THREE.SkinnedMesh
    Cube001_1: THREE.SkinnedMesh
    Cube001_2: THREE.SkinnedMesh
    Hair_1: THREE.SkinnedMesh
    Hair_2: THREE.SkinnedMesh
    Shoe: THREE.SkinnedMesh
    Plane: THREE.Mesh
    mixamorigHips: THREE.Bone
    Ctrl_ArmPole_IK_Left: THREE.Bone
    Ctrl_Hand_IK_Left: THREE.Bone
    Ctrl_ArmPole_IK_Right: THREE.Bone
    Ctrl_Hand_IK_Right: THREE.Bone
    Ctrl_Foot_IK_Left: THREE.Bone
    Ctrl_LegPole_IK_Left: THREE.Bone
    Ctrl_Foot_IK_Right: THREE.Bone
    Ctrl_LegPole_IK_Right: THREE.Bone
    Ctrl_Master: THREE.Bone
  }
  materials: {
    Body: THREE.MeshStandardMaterial
    Head: THREE.MeshStandardMaterial
    ['Eye 2']: THREE.MeshStandardMaterial
    ['Hair 1']: THREE.MeshStandardMaterial
    ['Hair 2']: THREE.MeshStandardMaterial
    Shoes: THREE.MeshStandardMaterial
    ['Eye 1']: THREE.MeshStandardMaterial
  }
  animations: GLTFActions[]
}

type CharacterProps = JSX.IntrinsicElements['group'] & {
  hair: number,
  eyes: number,
  moveable: boolean,
  startPosition: number[],
  orbitRef?: any
}

type KeyProps = {
  ArrowUp?: boolean,
  ArrowDown?: boolean,
  ArrowLeft?: boolean,
  ArrowRight?: boolean,
  W?: boolean,
  S?: boolean,
  A?: boolean,
  D?: boolean
}

const MovingSpeed : number = 5;
export default function Character(props: CharacterProps) {
  const group = useRef<THREE.Group>()
  const [ref, api] = useCylinder(() => ({
    args: [1, 1, 4, 16],
    position: [0, 2, 0],
  }))
  const rotateAngle = useRef<THREE.Vector3>(new THREE.Vector3(0, 1, 0));
  const rotateQuarternion = useRef(new THREE.Quaternion());
  const walkDirection = useRef(new THREE.Vector3());
  const currentClip = useRef<THREE.AnimationClip>(null);
  const { nodes, materials, animations } = useGLTF('/models/Character.glb') as GLTFResult
  const { actions, mixer } = useAnimations<GLTFActions>(animations, group)
  const { orbitRef } = props;
  const [keyPressed, setKeyPressed] = useState<KeyProps>({});

  const velocity = useRef<Triplet>([0, 0, 0])
  const position = useRef<Triplet>([0, 0, 0])

  useEffect(() => {
    api.velocity.subscribe(v => velocity.current = v);
    api.position.subscribe(v => position.current = v);
  }, [])

  const getMovingVector = () => {
    const vector = new THREE.Vector3();
    if (!keyPressed) {
        return vector;
    }
    if (keyPressed.ArrowUp || keyPressed.W) {
        vector.z = 1;
    }
    if (keyPressed.ArrowDown || keyPressed.S) {
        if (keyPressed.ArrowUp || keyPressed.W) {
            vector.z = 0;
        } else {
            vector.z = -1;
        }
    }

    if (keyPressed.ArrowRight || keyPressed.D) {
        vector.x = 1;
    }
    if (keyPressed.ArrowLeft || keyPressed.A) {
        if (keyPressed.ArrowRight || keyPressed.D) {
            vector.x = 0;
        } else {
            vector.x = -1;
        }
    }
    return vector;
};

const isMoving = () => {
  const moveVector = getMovingVector();
  return Math.abs(moveVector.x) > 0.1 || Math.abs(moveVector.z) > 0.1;
};

const getDirectionOffset = () => {
  const vector = getMovingVector();
  var directionOffset = 0;
  if (vector.z === 1) {
      if (vector.x === -1) {
          directionOffset = Math.PI + Math.PI / 4;
      } else if (vector.x === 1) {
          directionOffset = Math.PI - Math.PI / 4;
      } else {
          directionOffset = Math.PI;
      }
  } else if (vector.z === -1) {
      if (vector.x === -1) {
          directionOffset = 2 * Math.PI - Math.PI / 4;
      } else if (vector.x === 1) {
          directionOffset = 2 * Math.PI + Math.PI / 4;
      } else {
          directionOffset = 2 * Math.PI;
      }
  } else {
      directionOffset = -(-vector.x * Math.PI) / 2;
  }
  return directionOffset;
};

  useThree(({ camera }) => {
    if (!props.moveable) {
        camera.position.set(0, 0, 5);
        camera.rotation.set(0, 0, 0);
    }
  });

  useFrame((state, delta) => {
    const { camera } = state;
    
    //api.position.set(0.1, 0, 0);
    let clip: THREE.AnimationClip = null;
    if (props.moveable && isMoving()) {
        clip = actions.Walking;

        const yCameraDirection = Math.atan2(
            camera.position.x - ref.current.position.x,
            camera.position.z - ref.current.position.z
        );
        const directionOffset = getDirectionOffset();
        rotateQuarternion.current.setFromAxisAngle(rotateAngle.current, yCameraDirection + directionOffset);
        ref.current.quaternion.rotateTowards(rotateQuarternion.current, delta * 10);
        camera.getWorldDirection(walkDirection.current);
        walkDirection.current.y = 0;
        walkDirection.current.normalize();
        walkDirection.current.applyAxisAngle(rotateAngle.current, directionOffset + Math.PI);
        const moveX = walkDirection.current.x * MovingSpeed * delta;
        const moveZ = walkDirection.current.z * MovingSpeed * delta;
        
        //api.velocity.set(0.1, 0, 0);
        api.position.set(position.current[0] + moveX, position.current[1], position.current[2] + moveZ);
        
        if (orbitRef.current) {
            orbitRef.current.target = ref.current.position;
        }
    } else {
        clip = actions.Idle;
    }
    if (clip && clip !== currentClip.current) {
        if (currentClip.current) {
            currentClip.current.fadeOut(0.2);
        }
        clip.reset().fadeIn(0.2).play();
        currentClip.current = clip;
    }
    currentClip.current = clip;
    mixer.update(delta * 0.2);
});

  useEffect(() => {
    actions.Idle?.play();
    if (!props.moveable) {
        return;
    }

    document.addEventListener("keydown", (event) => {
        setKeyPressed((keyPressed) => ({ ...keyPressed, [event.key]: true }));
    });
    document.addEventListener("keyup", (event) => {
        setKeyPressed((keyPressed) => ({ ...keyPressed, [event.key]: false }));
    });

    orbitRef.current.target = ref.current?.position;
  }, [actions.Idle, orbitRef, ref, props.moveable]);

  useEffect(() => {
      if (ref.current) {
        ref.current.position.set(props.startPosition[0], props.startPosition[1], props.startPosition[2]);
      }
  }, [props.startPosition]);

  useEffect(() => {
    console.log(walkDirection.current);
  })

  return (
    <>      
      <group ref={ref} {...props} dispose={null}>
        <primitive object={nodes.mixamorigHips} />
        <primitive object={nodes.Ctrl_ArmPole_IK_Left} />
        <primitive object={nodes.Ctrl_Hand_IK_Left} />
        <primitive object={nodes.Ctrl_ArmPole_IK_Right} />
        <primitive object={nodes.Ctrl_Hand_IK_Right} />
        <primitive object={nodes.Ctrl_Foot_IK_Left} />
        <primitive object={nodes.Ctrl_LegPole_IK_Left} />
        <primitive object={nodes.Ctrl_Foot_IK_Right} />
        <primitive object={nodes.Ctrl_LegPole_IK_Right} />
        <primitive object={nodes.Ctrl_Master} />
        <skinnedMesh geometry={nodes.Cube001.geometry} material={materials.Body} skeleton={nodes.Cube001.skeleton} />
        <skinnedMesh geometry={nodes.Cube001_1.geometry} material={materials.Head} skeleton={nodes.Cube001_1.skeleton} />
        <skinnedMesh
          geometry={nodes.Cube001_2.geometry}
          material={props.eyes === 1 ? materials["Eye 1"] : materials["Eye 2"]}
          skeleton={nodes.Cube001_2.skeleton}
        />
        {props.hair === 1 ? (
            <skinnedMesh
                geometry={nodes.Hair_1.geometry}
                material={materials["Hair 1"]}
                skeleton={nodes.Hair_1.skeleton}
            />
        ) : (
            <skinnedMesh
                geometry={nodes.Hair_2.geometry}
                material={materials["Hair 2"]}
                skeleton={nodes.Hair_2.skeleton}
            />
        )}
        <skinnedMesh geometry={nodes.Shoe.geometry} material={materials.Shoes} skeleton={nodes.Shoe.skeleton} />
      </group>
    </>   
  )
}

useGLTF.preload('/Character.glb')
