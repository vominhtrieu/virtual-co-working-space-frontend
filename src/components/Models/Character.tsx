/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from 'three'
import {useEffect, useRef, useState} from 'react'
import {useGLTF, useAnimations} from '@react-three/drei'
import {useThree, useFrame} from '@react-three/fiber'
import {GLTF} from 'three-stdlib/loaders/GLTFLoader'
import {CollideEvent, Triplet, useCylinder} from '@react-three/cannon'
import socket from '../../services/socket/socket'
import { loadPlugin } from 'immer/dist/internal'

type ActionName = 'Idle' | 'Walking'

//type GLTFActions = Record<ActionName, THREE.AnimationAction>
interface GLTFActions extends THREE.AnimationClip {
    name: ActionName
}

type GLTFResult = GLTF & {
    nodes: {
        Cube001: THREE.SkinnedMesh
        Cube001_1: THREE.SkinnedMesh
        Cube001_2: THREE.SkinnedMesh
        Hair_1: THREE.SkinnedMesh
        Hair_2: THREE.SkinnedMesh
        Shoe: THREE.SkinnedMesh
        Plane: THREE.Mesh
        mixamorigHips: THREE.Bone
        Ctrl_ArmPole_IK_Left: THREE.Bone
        Ctrl_Hand_IK_Left: THREE.Bone
        Ctrl_ArmPole_IK_Right: THREE.Bone
        Ctrl_Hand_IK_Right: THREE.Bone
        Ctrl_Foot_IK_Left: THREE.Bone
        Ctrl_LegPole_IK_Left: THREE.Bone
        Ctrl_Foot_IK_Right: THREE.Bone
        Ctrl_LegPole_IK_Right: THREE.Bone
        Ctrl_Master: THREE.Bone
    }
    materials: {
        Body: THREE.MeshStandardMaterial
        Head: THREE.MeshStandardMaterial
        ['Eye 2']: THREE.MeshStandardMaterial
        ['Hair 1']: THREE.MeshStandardMaterial
        ['Hair 2']: THREE.MeshStandardMaterial
        Shoes: THREE.MeshStandardMaterial
        ['Eye 1']: THREE.MeshStandardMaterial
    }
    animations: GLTFActions[]
}

type CharacterProps = JSX.IntrinsicElements['group'] & {
    hair: number,
    eyes: number,
    moveable: boolean,
    startPosition: number[],
    orbitRef?: any
}

type KeyProps = {
    ArrowUp?: boolean,
    ArrowDown?: boolean,
    ArrowLeft?: boolean,
    ArrowRight?: boolean,
    W?: boolean,
    S?: boolean,
    A?: boolean,
    D?: boolean
}

function useCustomGLTF(path: string): GLTFResult {
    const result = useGLTF(path) as GLTFResult;

    const colors = new Uint8Array(2);

    for (let c = 0; c <= colors.length; c++) {
        colors[c] = (c / colors.length) * 256;
    }

    const gradientMap = new THREE.DataTexture(colors, colors.length, 1, THREE.RedFormat);
    gradientMap.needsUpdate = true;

    if (result.materials) {
        for (let key in result.materials) {
            const currentMaterial = result.materials[key];

            const material = new THREE.MeshToonMaterial({
                color: currentMaterial.color,
                gradientMap: gradientMap,
                map: currentMaterial.map,
            });

            result.materials[key] = material;
        }
    }

    return result;
}

const MovingSpeed: number = 5;
export default function Character(props: CharacterProps) {
    const group = useRef<THREE.Group>()
    const [ref, api] = useCylinder(() => ({
        args: [1, 1, 4, 8],
        type: "Dynamic",
        fixedRotation: true,
        mass: 1,
    }))
    const rotateAngle = useRef<THREE.Vector3>(new THREE.Vector3(0, 1, 0));
    const rotateQuarternion = useRef(new THREE.Quaternion());
    const walkDirection = useRef(new THREE.Vector3());
    const currentClip = useRef<THREE.AnimationClip>(null);
    const {nodes, materials, animations} = useCustomGLTF('/models/Character.glb') as GLTFResult
    const {actions, mixer} = useAnimations<GLTFActions>(animations, group)
    const {orbitRef} = props;
    const [keyPressed, setKeyPressed] = useState<KeyProps>({});

    const position = useRef([0, 0, 0])
    const updatedPosition = useRef(props.startPosition)

    useEffect(() => {
        socket.emit("office_member:join", {
            officeId: "4"
        })
    }, [])

    useEffect(() => {
        api.position.subscribe((v) => {
            position.current = v;
        })
    }, [api.position])

    const getMovingVector = () => {
        const vector = new THREE.Vector3();
        if (!keyPressed) {
            return vector;
        }
        if (keyPressed.ArrowUp || keyPressed.W) {
            vector.z = 1;
        }
        if (keyPressed.ArrowDown || keyPressed.S) {
            if (keyPressed.ArrowUp || keyPressed.W) {
                vector.z = 0;
            } else {
                vector.z = -1;
            }
        }

        if (keyPressed.ArrowRight || keyPressed.D) {
            vector.x = 1;
        }
        if (keyPressed.ArrowLeft || keyPressed.A) {
            if (keyPressed.ArrowRight || keyPressed.D) {
                vector.x = 0;
            } else {
                vector.x = -1;
            }
        }
        return vector;
    };

    const isMoving = () => {
        const moveVector = getMovingVector();
        return Math.abs(moveVector.x) > 0.1 || Math.abs(moveVector.z) > 0.1;
    };

    const getDirectionOffset = () => {
        const vector = getMovingVector();
        var directionOffset = 0;
        if (vector.z === 1) {
            if (vector.x === -1) {
                directionOffset = Math.PI + Math.PI / 4;
            } else if (vector.x === 1) {
                directionOffset = Math.PI - Math.PI / 4;
            } else {
                directionOffset = Math.PI;
            }
        } else if (vector.z === -1) {
            if (vector.x === -1) {
                directionOffset = 2 * Math.PI - Math.PI / 4;
            } else if (vector.x === 1) {
                directionOffset = 2 * Math.PI + Math.PI / 4;
            } else {
                directionOffset = 2 * Math.PI;
            }
        } else {
            directionOffset = -(-vector.x * Math.PI) / 2;
        }
        return directionOffset;
    };

    const shouldUpdate = () => {
        return Math.sqrt(Math.pow(position.current[0] - updatedPosition.current[0], 2) + Math.pow(position.current[2] - updatedPosition.current[2], 2)) > 0.1
    }

    useThree(({camera}) => {
        if (!props.moveable) {
            camera.position.set(0, 0, 5);
            camera.rotation.set(0, 0, 0);
        }
    });

    useFrame((state, delta) => {
        const {camera} = state;

        //api.position.set(0.1, 0, 0);
        let clip: THREE.AnimationClip = null;
        if (props.moveable && isMoving()) {
            clip = actions.Walking;

            const yCameraDirection = Math.atan2(
                camera.position.x - ref.current.position.x,
                camera.position.z - ref.current.position.z
            );
            const directionOffset = getDirectionOffset();
            rotateQuarternion.current.setFromAxisAngle(rotateAngle.current, yCameraDirection + directionOffset);
            ref.current.quaternion.rotateTowards(rotateQuarternion.current, delta * 10);
            camera.getWorldDirection(walkDirection.current);
            walkDirection.current.y = 0;
            walkDirection.current.normalize();
            walkDirection.current.applyAxisAngle(rotateAngle.current, directionOffset + Math.PI);
            const moveX = walkDirection.current.x * MovingSpeed;
            const moveZ = walkDirection.current.z * MovingSpeed;

            api.velocity.set(moveX, 0, moveZ);
            // api.position.set(position.current[0] + moveX, position.current[1], position.current[2] + moveZ);

            if (orbitRef.current) {
                orbitRef.current.target = ref.current.position;
            }

            updatedPosition.current = position.current;
            
            socket.emit("office_member:move", {
                xRotation: 0,
                yRotation: 1,
                zRotation: 5,
                xPosition: position.current[0],
                yPosition: position.current[1],
                zPosition: position.current[2]
            })

        } else {
            clip = actions.Idle;
            api.velocity.set(0, 0, 0);
        }
        
        //update from remote position
        if (shouldUpdate()) {
            walkDirection.current = new THREE.Vector3(updatedPosition.current[0] - position.current[0], 0, updatedPosition.current[2] - position.current[2]);
            walkDirection.current.y = 0;
            walkDirection.current.normalize();
            const moveX = walkDirection.current.x * MovingSpeed;
            const moveZ = walkDirection.current.z * MovingSpeed;

            api.velocity.set(moveX, 0, moveZ);
        }

        if (clip && clip !== currentClip.current) {
            if (currentClip.current) {
                currentClip.current.fadeOut(0.2);
            }
            clip.reset().fadeIn(0.2).play();
            currentClip.current = clip;
        }
        currentClip.current = clip;
        mixer.update(delta * 0.2);
    });

    useEffect(() => {
        actions.Idle?.play();
        if (!props.moveable) {
            return;
        }

        document.addEventListener("keydown", (event) => {
            setKeyPressed((keyPressed) => ({...keyPressed, [event.key]: true}));
        });
        document.addEventListener("keyup", (event) => {
            setKeyPressed((keyPressed) => ({...keyPressed, [event.key]: false}));
        });

        orbitRef.current.target = ref.current?.position;
    }, [actions.Idle, orbitRef, ref, props.moveable]);

    useEffect(() => {
        if (ref.current) {
            ref.current.position.set(props.startPosition[0], props.startPosition[1], props.startPosition[2]);
            api.position.set(props.startPosition[0], props.startPosition[1], props.startPosition[2]);
        }
    }, [ref.current, props.startPosition]);

    socket.on("office_member:moved", (message) => {
        updatedPosition.current = [message.xPosition, message.yPosition, message.zPosition];
        
        // const walkDirection = new THREE.Vector3(message.xPosition - position.current[0], 0, message.zPosition - position.current[2]);
        // walkDirection.normalize();
        // const moveX = walkDirection.x * MovingSpeed;
        // const moveZ = walkDirection.z * MovingSpeed;

        // api.velocity.set(moveX, 0, moveZ);
    })

    return (
        <>
            <mesh ref={ref} {...props}>
                <group position={[0,-1,0]} dispose={null}>
                    <primitive object={nodes.mixamorigHips}/>
                    <primitive object={nodes.Ctrl_ArmPole_IK_Left}/>
                    <primitive object={nodes.Ctrl_Hand_IK_Left}/>
                    <primitive object={nodes.Ctrl_ArmPole_IK_Right}/>
                    <primitive object={nodes.Ctrl_Hand_IK_Right}/>
                    <primitive object={nodes.Ctrl_Foot_IK_Left}/>
                    <primitive object={nodes.Ctrl_LegPole_IK_Left}/>
                    <primitive object={nodes.Ctrl_Foot_IK_Right}/>
                    <primitive object={nodes.Ctrl_LegPole_IK_Right}/>
                    <primitive object={nodes.Ctrl_Master}/>
                    <skinnedMesh geometry={nodes.Cube001.geometry} material={materials.Body}
                                 skeleton={nodes.Cube001.skeleton}/>
                    <skinnedMesh geometry={nodes.Cube001_1.geometry} material={materials.Head}
                                 skeleton={nodes.Cube001_1.skeleton}/>
                    <skinnedMesh
                        geometry={nodes.Cube001_2.geometry}
                        material={props.eyes === 1 ? materials["Eye 1"] : materials["Eye 2"]}
                        skeleton={nodes.Cube001_2.skeleton}
                    />
                    {props.hair === 1 ? (
                        <skinnedMesh
                            geometry={nodes.Hair_1.geometry}
                            material={materials["Hair 1"]}
                            skeleton={nodes.Hair_1.skeleton}
                        />
                    ) : (
                        <skinnedMesh
                            geometry={nodes.Hair_2.geometry}
                            material={materials["Hair 2"]}
                            skeleton={nodes.Hair_2.skeleton}
                        />
                    )}
                    <skinnedMesh geometry={nodes.Shoe.geometry} material={materials.Shoes}
                                 skeleton={nodes.Shoe.skeleton}/>
                </group>
            </mesh>
        </>
    )
}

useGLTF.preload('/Character.glb')
