/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useEffect, useMemo, useRef, useState } from 'react';
import * as THREE from "three";
import { useCustomGLTF } from '../../helpers/utilities';
import { v4 } from "uuid";
import Peer from 'peerjs';
import { useAppSelector } from "../../stores";
import { socketSelector } from '../../stores/socket-slice';
import { matchPath } from 'react-router-dom';
import { userSelectors } from '../../stores/auth-slice';

export default function Model(props) {
  const group = useRef();
  const { nodes, materials } = useCustomGLTF('/models/TV.glb');
  const [stream, setStream] = useState<MediaStream | null>(null);
  const socket = useAppSelector(socketSelector.getSocket);
  const userInfo = useAppSelector(userSelectors.getUserInfo);
  const match = matchPath({ path: "/office/:id" }, window.location.pathname);
  const [callerId, setCallerId] = useState("");
  const officeId = match?.params.id;
  const id = useMemo(() => v4(), []);

  const myPeer = useMemo(
    () => {
      const p = new Peer(id, {
        host: process.env.REACT_APP_PEER_SERVER_HOST + "",
        port: +(process.env.REACT_APP_PEER_SERVER_PORT + ""),
        path: "/peer",
      });
      p.on("error", (err) => {
        console.log(err);
      })
      return p;
    }, []);

  useEffect(() => {
    socket.on("calling:share-screen", (data) => {
      if (data.callerId !== callerId) {
        setTimeout(() => {
          navigator.mediaDevices.getUserMedia({
            audio: {
              width: 256,
              height: 256,
            },
            video: false,
          }).then((stream: MediaStream) => {
            const call = myPeer.call(data.callerId, stream);
            console.log("hiii")
            call.on("error", (err) => {
              console.log(err)
            })
            call.on("stream", (stream) => {
              setStream(stream);
              console.log("hiiiii")
            })
            call.on("close", () => "Closed")
          })
        }, 1000)
      }
    })
    return () => {
      socket.removeAllListeners("calling:share-screen");
    }
  }, [socket, myPeer, callerId]);

  const shareScreen = () => {
    if (props.action === "config")
      return;
    navigator.mediaDevices.getUserMedia({
      video: {
        width: 720,
        height: 480,
      },
      audio: false,
    }).then((stream: MediaStream) => {
      setStream(stream);
      socket.emit("calling:share-screen", {
        officeId: +(officeId + ""),
        callerId: myPeer.id,
      })
      myPeer.on("call", (call) => {
        call.answer(stream);
        call.on("error", (err) => {
          console.log(err)
        })
        call.on("stream", (stream) => {})
        call.on("close", () => "Closed")
      });
    });
  }

  const videoTexture = useMemo(() => {
    if (!stream) {
      return null;
    }

    const selfVideo = document.createElement("video");
    selfVideo.muted = true;
    selfVideo.srcObject = stream;
    selfVideo.addEventListener("loadedmetadata", () => {
      selfVideo.play();
    });
    return new THREE.VideoTexture(selfVideo);
  }, [stream])
  if (videoTexture)
    materials.Material.map = videoTexture;

  const material = new THREE.MeshBasicMaterial({ color: 0xffffff, map: videoTexture });
  return (
    <group ref={group} {...props}>
      <mesh geometry={nodes.Cube_1.geometry} material={materials.Border} />
      <mesh geometry={nodes.Cube_2.geometry} material={material} onDoubleClick={shareScreen} />
    </group>
  )
}